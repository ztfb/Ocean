## Transaction
Transaction类通过维护XID文件来维护每个事务的状态，并给其他模块提供接口来修改或查询某个事务的状态。
XID文件格式的定义：
在Ocean中，每个事务都有一个ID（XID），这个 ID 唯一标识了这个事务。事务的XID从1开始标号，并自增，不可重复。
注：规定XID为0的事务是一个超级事务。当一些操作想在不申请事务的情况下进行，那么可以将操作的XID设置为0。超级事务的状态永远是committed。
Ocean中，每个事务都有下面的三种状态： active：正在进行，尚未结束； committed：已提交 aborted：已撤销（回滚）。
XID文件给每个事务分配了一个字节的空间，用来保存其状态。同时，在 XID 文件的头部，还保存了一个 8 字节的数字，记录了这个 XID 文件管理的事务的个数。
于是，事务 xid 在文件中的状态就存储在 (xid-1)+8 字节处。xid 0的状态不需要记录。
Transaction初始化时，首先要对 XID 文件进行校验，以保证这是一个合法的 XID 文件。校验的方式也很简单，通过文件头的 8 字节数字反推文件的理论长度，与文件的实际长度做对比。如果不同则认为 XID 文件不合法。
注：对于校验没有通过的，会直接通过 panic 方法，强制停机。在一些基础模块中出现错误都会如此处理，无法恢复的错误只能直接停机。
注：这里的所有文件操作，在执行后都需要立刻刷入文件中，防止在崩溃后文件丢失数据

## DataManager
DM直接管理数据库的DB文件和日志文件。DM 的主要职责有：分页管理 DB 文件，并进行缓存；管理日志文件，保证在发生错误时可以根据日志进行恢复；抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。
DM 的功能其实可以归纳为两点：上层模块和文件系统之间的一个抽象层，向下直接读写文件，向上提供数据的包装；另外就是日志功能。
### Cache
由于分页管理和数据项（DataItem）管理都涉及缓存，这里设计一个更通用的缓存框架。这里使用的缓存策略为引用计数，而非LRU，原因如下：
如果使用 LRU 缓存，那么只需要设计一个 get(key) 接口即可，释放缓存可以在缓存满了之后自动完成。
设想这样一个场景：某个时刻缓存满了，缓存驱逐了一个资源，这时上层模块想要将某个资源强制刷回数据源，这个资源恰好是刚刚被驱逐的资源。那么上层模块就发现，这个数据在缓存里消失了，这是是否有必要做回源操作？
1.不回源。由于没法确定缓存被驱逐的时间，更没法确定被驱逐之后数据项是否被修改，这样是极其不安全的
2.回源。如果数据项被驱逐时的数据和现在又是相同的，那就是一次无效回源
3.放回缓存里，等下次被驱逐时回源。看起来解决了问题，但是此时缓存已经满了，这意味着你还需要驱逐一个资源才能放进去。这有可能会导致缓存抖动问题
问题的根源还是，LRU 策略中，资源驱逐不可控，上层模块无法感知。而引用计数策略正好解决了这个问题，只有上层模块主动释放引用，缓存在确保没有模块在使用这个资源了，才会去驱逐资源。
引用计数法增加了一个方法 release(key)，用于在上册模块不使用某个资源时，释放对资源的引用。当引用归零时，缓存就会驱逐这个资源。
同样，在缓存满了之后，引用计数法无法自动释放缓存，此时应该直接报错。
这样，一个简单的缓存框架就实现完了，其他的缓存只需要继承这个类，并实现那两个抽象方法即可。
### Page
DM 将文件系统抽象成页面，每次对文件系统的读写都是以页面为单位的。同样，从文件系统读进来的数据也是以页面为单位进行缓存的。
这里参考大部分数据库的设计，将默认数据页大小定为4K。如果想要提升向数据库写入大量数据情况下的性能的话，也可以适当增大这个值。
我们现在需要缓存页面，就可以直接借用上述缓存框架。但是首先，需要定义出页面的结构。注意这个页面是存储在内存中的，与已经持久化到磁盘的抽象页面有区别。
pageNumber记录了当前打开的数据库文件有多少页。这个数字在数据库文件被打开时就会被计算，并在新建页面时自增。
注：同一条数据是不允许跨页存储的，这意味着，单条数据的大小不能超过数据库页面的大小。
数据库文件的第一页，通常用作一些特殊用途，比如存储一些元数据，用来启动检查。
Ocean的第一页，只是用来做启动检查。 具体的原理是，在每次数据库启动时，会生成一串随机字节，存储在0-63字节。在数据库正常关闭时，会将这串字节，拷贝到第一页的64-127字节。
这样数据库在每次启动时，就会检查第一页两处的字节是否相同，以此来判断上一次是否正常关闭。如果是异常关闭，就需要执行数据的恢复流程。
一个普通页面以一个 2 字节无符号数起始，表示这一页的空闲位置的偏移。剩下的部分都是实际存储的数据。
### Recover
日志系统：
MYDB 提供了崩溃后的数据恢复功能。DM 层在每次对底层数据操作时，都会记录一条日志到磁盘上。在数据库奔溃之后，再次启动时，可以根据日志的内容，恢复数据文件，保证其一致性。
Logger被实现成迭代器模式，通过 next() 方法，不断地从文件中读取下一条日志，并将其中的 Data 解析出来并返回。next() 方法的实现主要依靠 nextLog()。
在打开一个日志文件时，需要首先校验日志文件的 XChecksum，并移除文件尾部可能存在的 BadTail，由于 BadTail 该条日志尚未写入完成，文件的校验和也就不会包含该日志的校验和，去掉 BadTail 即可保证日志文件的一致性。
向日志文件写入日志时，也是首先将数据包裹成日志格式，写入文件后，再更新文件的校验和，更新校验和时，会刷新缓冲区，保证内容写入磁盘。
恢复系统：
DM 为上层模块，提供了两种操作，分别是插入新数据（I）和更新现有数据（U）。 DM 的日志策略很简单： 在进行 I 和 U 操作之前，必须先进行对应的日志操作，在保证日志写入磁盘后，才进行数据操作。
这个日志策略，使得 DM 对于数据操作的磁盘同步，可以更加随意。日志在数据操作之前，保证到达了磁盘，那么即使该数据操作最后没有来得及同步到磁盘，数据库就发生了崩溃，后续也可以通过磁盘上的日志恢复该数据。
对于两种数据操作，DM 记录的日志如下：(Ti, I, A, x)，表示事务 Ti 在 A 位置插入了一条数据 x  (Ti, U, A, oldx, newx)，表示事务 Ti 将 A 位置的数据，从 oldx 更新成 newx
由于单线程，Ti、Tj 和 Tk 的日志永远不会相交。这种情况下利用日志恢复很简单，假设日志中最后一个事务是 Ti：
对 Ti 之前所有的事务的日志，进行重做（redo）
接着检查 Ti 的状态（XID 文件），如果 Ti 的状态是已完成（包括 committed 和 aborted），就将 Ti 重做，否则进行撤销（undo）
接着，是如何对事务 T 进行 redo： 正序扫描事务 T 的所有日志 ,如果日志是插入操作 (Ti, I, A, x)，就将 x 重新插入 A 位置 ,如果日志是更新操作 (Ti, U, A, oldx, newx)，就将 A 位置的值设置为 newx
undo 也很好理解： 倒序扫描事务 T 的所有日志 ,如果日志是插入操作 (Ti, I, A, x)，就将 A 位置的数据删除 ,如果日志是更新操作 (Ti, U, A, oldx, newx)，就将 A 位置的值设置为 oldx

对于多线程的情况，存在一些问题, 归根结底是因为我们的日志太过简单, 仅仅记录了"前相"和"后相". 并单纯的依靠"前相"undo, 依靠"后相"redo. 这种简单的日志方式和恢复方式, 并不能涵盖住所有数据库操作形成的语义解决方法有两种：
增加日志种类 限制数据库操作 ，这里采用的是限制数据库操作，需要保证：
规定1：正在进行的事务，不会读取其他任何未提交的事务产生的数据。
规定2：正在进行的事务，不会修改其他任何未提交的事务修改或产生的数据。
在 Ocean 中，由于 VM 的存在，传递到 DM 层，真正执行的操作序列，都可以保证规定 1 和规定 2。有了这两条规定，并发情况下日志的恢复也就很简单了： 重做所有崩溃时已完成（committed 或 aborted）的事务 ，撤销所有崩溃时未完成（active）的事务
在恢复后，数据库就会恢复到所有已完成事务结束，所有未完成事务尚未开始的状态。

注意，MYDB 中其实没有真正的删除操作，对于插入操作的 undo，只是将其中的标志位设置为 invalid。对于删除的探讨将在 VM 一节中进行。
我们首先不考虑并发的情况，那么在某一时刻，只可能有一个事务在操作数据库。日志会看起来像下面那样：
### PageIndex
页面索引，缓存了每一页的空闲空间。用于在上层模块进行插入操作时，能够快速找到一个合适空间的页面，而无需从磁盘或者缓存中检查每一个页面的信息。
这里用一个比较粗略的算法实现了页面索引，将一页的空间划分成了100个区间。在启动时，就会遍历所有的页面信息，获取页面的空闲空间，安排到这100个区间中。
insert 在请求一个页时，会首先将所需的空间向上取整，映射到某一个区间，随后取出这个区间的任何一页，都可以满足需求。 PageIndex 的实现也很简单，一个 List 类型的数组。
注：可以注意到，被选择的页，会直接从 PageIndex 中移除，这意味着，同一个页面是不允许并发写的。在上层模块使用完这个页面后，需要将其重新插入 PageIndex

DataItem 是 DM 层向上层提供的数据抽象。上层模块通过地址，向 DM 请求到对应的 DataItem，再获取到其中的数据。dm 同时实现了缓存接口，用于缓存 DataItem
在上层模块试图对 DataItem 进行修改时，需要遵循一定的流程：在修改之前需要调用 before() 方法，想要撤销修改时，调用 unBefore() 方法，在修改完成后，调用 after() 方法。
整个流程，主要是为了保存前相数据，并及时落日志。DM 会保证对 DataItem 的修改是原子性的。

DataManager 是 DM 层直接对外提供方法的类，同时，也实现成 DataItem 对象的缓存。DataItem 存储的 key，是由页号和页内偏移组成的一个 8 字节无符号整数，页号和偏移各占 4 字节。
DataItem 缓存，getForCache()，只需要从 key 中解析出页号，从 pageCache 中获取到页面，再根据偏移，解析出 DataItem 即可
DataItem 缓存释放，需要将 DataItem 写回数据源，由于对文件的读写是以页为单位进行的，只需要将 DataItem 所在的页 release 即可
从已有文件创建 DataManager 和从空文件创建 DataManager 的流程稍有不同，从空文件创建首先需要对第一页进行初始化，而从已有文件创建，则是需要对第一页进行校验，来判断是否需要执行恢复流程。并重新对第一页生成随机字节。
read() 根据 UID 从缓存中获取 DataItem，并校验有效位
insert() 方法，在 pageIndex 中获取一个足以存储插入内容的页面的页号，获取页面后，首先需要写入插入日志，接着才可以插入数据，并返回插入位置的偏移。最后需要将页面信息重新插入 pageIndex

## VersionManager
VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。
Version Manager 是 Ocean 的事务和数据版本的管理核心。

首先来定义数据库的冲突，暂时不考虑插入操作，只看更新操作（U）和读操作（R），两个操作只要满足下面三个条件，就可以说这两个操作相互冲突：
这两个操作是由不同的事务执行的 ,这两个操作操作的是同一个数据项 ,这两个操作至少有一个是更新操作
那么这样，对同一个数据操作的冲突，其实就只有下面这两种情况：
两个不同事务的 U 操作冲突 ,两个不同事务的 U、R 操作冲突
交换两个互不冲突的操作的顺序，不会对最终的结果造成影响，而交换两个冲突操作的顺序，则是会有影响的。
VM 的一个很重要的职责，就是实现了调度序列的可串行化。MYDB 采用两段锁协议（2PL）来实现。
当采用 2PL 时，如果某个事务 i 已经对 x 加锁，且另一个事务 j 也想操作 x，但是这个操作与事务 i 之前的操作相互冲突的话，事务 j 就会被阻塞。譬如，T1 已经因为 U1(x) 锁定了 x，那么 T2 对 x 的读或者写操作都会被阻塞，T2 必须等待 T1 释放掉对 x 的锁。

由此来看，2PL 确实保证了调度序列的可串行话，但是不可避免地导致了事务间的相互阻塞，甚至可能导致死锁。Ocean 为了提高事务处理的效率，降低阻塞概率，实现了 MVCC。
DM 层向上层提供了数据项（Data Item）的概念，VM 通过管理所有的数据项，向上层提供了记录（Entry）的概念。上层模块通过 VM 操作数据的最小单位，就是记录。
VM 则在其内部，为每个记录，维护了多个版本（Version）。每当上层模块对某个记录进行修改时，VM 就会为这个记录创建一个新的版本。
Ocean 通过 MVCC，降低了事务的阻塞概率。譬如，T1 想要更新记录 X 的值，于是 T1 需要首先获取 X 的锁，接着更新，也就是创建了一个新的 X 的版本，假设为 x3。假设 T1 还没有释放 X 的锁时，T2 想要读取 X 的值，这时候就不会阻塞，Ocean 会返回一个较老版本的 X，例如 x2。这样最后执行的结果，就等价于，T2 先执行，T1 后执行，调度序列依然是可串行化的。如果 X 没有一个更老的版本，那只能等待 T1 释放锁了。所以只是降低了概率。
为了保证数据的可恢复，VM 层传递到 DM 的操作序列需要满足以下两个规则：
规定 1：正在进行的事务，不会读取其他任何未提交的事务产生的数据。 
规定 2：正在进行的事务，不会修改其他任何未提交的事务修改或产生的数据。
由于 2PL 和 MVCC，我们可以看到，这两个条件都被很轻易地满足了。

### Entry
记录的实现 :对于一条记录来说，Ocean 使用 Entry 类维护了其结构。虽然理论上，MVCC 实现了多版本，但是在实现中，VM 并没有提供 Update 操作，对于字段的更新操作由后面的表和字段管理（TBM）实现。所以在 VM 的实现中，一条记录只有一个版本。
一条记录存储在一条 Data Item 中，所以 Entry 中保存一个 DataItem 的引用即可

### Transaction
需要提供一个结构，来抽象一个事务，以保存快照数据.构造方法中的 active，保存着当前所有 active 的事务。

事务的隔离级别
读提交
如果一个记录的最新版本被加锁，当另一个事务想要修改或读取这条记录时，Ocean 就会返回一个较旧的版本的数据。这时就可以认为，最新的被加锁的版本，对于另一个事务来说，是不可见的。于是版本可见性的概念就诞生了。
版本的可见性与事务的隔离度是相关的。Ocean 支持的最低的事务隔离程度，是“读提交”（Read Committed），即事务在读取数据时, 只能读取已经提交事务产生的数据。保证最低的读提交的好处，第四章中已经说明（防止级联回滚与 commit 语义冲突）。
Ocean 实现读提交，为每个版本维护了两个变量，就是上面提到的 XCRT 和 XDEL： 创建该版本的事务编号 ,删除该版本的事务编号
XCRT 应当在版本创建时填写，而 XDEL 则在版本被删除，或者有新版本出现时填写。
XDEL 这个变量，也就解释了为什么 DM 层不提供删除操作，当想删除一个版本时，只需要设置其 XDEL，这样，这个版本对每一个 XDEL 之后的事务都是不可见的，也就等价于删除了。

可重复读
不可重复度，会导致一个事务在执行期间对同一个数据项的读取得到不同结果。 可以看到，T1 两次读 X，读到的结果不一样。如果想要避免这个情况，就需要引入更严格的隔离级别，即可重复读（repeatable read）。
T1 在第二次读取的时候，读到了已经提交的 T2 修改的值，导致了这个问题。于是我们可以规定： 事务只能读取它开始时, 就已经结束的那些事务产生的数据版本
这条规定，增加于，事务需要忽略： 在本事务后开始的事务的数据; 本事务开始时还是 active 状态的事务的数据
对于第一条，只需要比较事务 ID，即可确定。而对于第二条，则需要在事务 Ti 开始时，记录下当前活跃的所有事务 SP(Ti)，如果记录的某个版本，XMIN 在 SP(Ti) 中，也应当对 Ti 不可见。

### LockTable